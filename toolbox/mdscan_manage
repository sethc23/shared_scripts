#!env zsh

PT=0

# Set Workspace
BASE_DIR=$(pwd)
INPUT_DIR=.Projects
UUID_AS_FNAME=
OUTPUT_DIR_NAME=
# EXCLUDE_FOLDERS=(Home Office Trip)
EXCLUDE_FOLDERS=()
EXCLUDE_GRP_NAMES=(Common Home)
TMP_IMAGE_DIR=_images
EXTRACT_PROCESSED=
EXTRACT_ORIGS=true
ROTATION=
BUILD_METHOD=normal
# BUILD_METHOD=image_extraction
DRY_RUN=true
SINGLE_DIR=
VERBOSE=true
DEBUG=

# Functions

#
# for i in $(find . -mindepth 2 -maxdepth 2 -type d); do [[ $(echo "${#i}") != 17 ]] && echo $i; done
# remove_spaces_in_pwd_scan_group_dir; for _dir in $(find . -type d -name "Scan*"|sort); do cd $_dir; remove_spaces_in_pwd_scan_group_dir; cd ..; done
#
remove_spaces_in_pwd_scan_group_dir(){
    _cnt=$(find "$(pwd)" -maxdepth 1 -type d -name "Page*" | wc -l)
    _range=$(python2.7 -c "print( ' '.join([str(it) for it in range($_cnt)]) )")
    for i in $(echo $_range); do
        num=$(python -c "print(\"%03d\" % $i)")
        if [[ -d "./Page $i" ]]; then
            mv "./Page $i" "./Page$num"
        elif [[ -d "./Page$i" ]]; then
            mv "./Page$i" "./Page$num"
        fi
    done
    }
remove_spaces_in_pwd_scan_group_dirs(){
    _base_dir="$(pwd)"
    _cnt=$(find "$(pwd)" -maxdepth 1 -type d -name "Scan*" | wc -l)
    _range=$(python2.7 -c "print( ' '.join([str(it) for it in range($_cnt)]) )")
    for i in $(echo $_range); do
        num=$(python -c "print(\"%03d\" % $i)")
        _dir="./Scan$num"
        if [[ -d "./Scan $i" ]]; then
            mv "./Scan $i" $_dir
        elif [[ -d "./Scan$i" ]]; then
            mv "./Scan$i" $_dir
        else
            _dir=
        fi
        if [[ -n $_dir ]]; then
            cd "$_dir"
            remove_spaces_in_pwd_scan_group_dir
            cd "$_base_dir"
        fi
    done
    }
get_scan_info(){
    set_scan_name_date_from_last_file_stats(){
        last_dir=$(find . -type d -name "Page*"|sort|tail -n 1)
        SCAN_DATE=$(stat -c '%y' "$last_dir/page.jpg"|cut -d ' ' -f-2)
        SCAN_NAME=$SCAN_DATE
        SCAN_DATE=$(echo $SCAN_DATE | cut -d ' ' -f1)
        }
    unset SCAN_FNAME
    if [[ -n $UUID_AS_FNAME ]]; then
        SCAN_FNAME="$(uuidgen -t|cut -d '-' -f1)"

    elif [[ -f document.dat ]]; then

        # SCAN_NAME="$(cat document.dat | tr -d '\200-\377' \
        #             | sed -r 's/[^[:print:]]//g' \
        #             | sed -r 's/^([^[:digit:]]*)(.*)(Page0)(.*)$/\2/' \
        #             | sed -r 's/[^[:alnum:]:\.\ -]//g')"

        SCAN_NAME="$(python2.7 -c "$(cat <<EOF
import re
with open('document.dat','rb') as f: res = f.read()
res = re.sub(r'(?i)[^0-9a-z.:\s-]+','', res)
res = re.sub(r'[^\x00-\x7F]+','', res)
res = res.split('Page')[0]
res = re.sub(r'(?i)^[^0-9]+','', res)
res = re.sub(r'^(.*)(\d\d[.]\d\d[.]\d\d[ ]\d\d[:]\d\d[:]\d\d)[-]?(.*)$',r'\2-\3',res)
print(res.strip(' _-:'))
EOF
        )"
        )"
        SCAN_DATE=$(echo "$SCAN_NAME" | cut -d ' ' -f1 | sed 's/\./\//g')
        SCAN_DATE=20$(echo ${SCAN_DATE:${#SCAN_DATE}-8:#SCAN_DATE})       # Get last 8 characters
        _chk=$(date --date="$SCAN_DATE" 2>&1 | grep 'invalid date')
        _len=$(echo "${#SCAN_DATE}")
        if [[ (-n $_chk) || (! $_len = 10) ]]; then
            set_scan_name_date_from_last_file_stats
        fi
    else
        set_scan_name_date_from_last_file_stats
    fi
    # echo "SCAN_FNAME: $SCAN_FNAME"
    if [[ -z $SCAN_FNAME ]]; then
        SCAN_TIME_TITLE=$(echo $SCAN_NAME | cut -d ' ' -f2)
        SCAN_TIME=$(echo $SCAN_TIME_TITLE | cut -d '-' -f1)
        SCAN_TITLE=$(echo $SCAN_TIME_TITLE | cut -d '-' -f2-)
        [[ $SCAN_TIME = $SCAN_TITLE ]] && SCAN_TITLE=
        SCAN_GRP_NAME="$SCAN_GROUP_DIR"
        # echo "SCAN_GRP_NAME 1: $SCAN_GRP_NAME"
        for _grp_name in $EXCLUDE_GRP_NAMES; do
            if [[ $_grp_name = $SCAN_GRP_NAME ]]; then
                SCAN_GRP_NAME=
                break
            fi
        done
        # echo "SCAN_GRP_NAME 2: $SCAN_GRP_NAME"
        SCAN_DATETIME="$(date --date="$SCAN_DATE $SCAN_TIME" +'%Y.%m.%d_%H.%M.%S')"
        [[ (-n $SCAN_TITLE) && (-n $SCAN_GRP_NAME) ]]                                      \
            && SCAN_FNAME=$(printf "%s-%s-%s" $SCAN_DATETIME $SCAN_GRP_NAME $SCAN_TITLE)
        [[ (-z $SCAN_TITLE) && (-n $SCAN_GRP_NAME) ]]                                      \
            && SCAN_FNAME=$(printf "%s-%s" $SCAN_DATETIME $SCAN_GRP_NAME)
        [[ (-n $SCAN_TITLE) && (-z $SCAN_GRP_NAME) ]]                                      \
            && SCAN_FNAME=$(printf "%s-%s" $SCAN_DATETIME $SCAN_TITLE)
        [[ -z $SCAN_FNAME ]]                                                                \
            && SCAN_FNAME=$(printf "%s" $SCAN_DATETIME)
        # echo "SCAN_DATETIME: $SCAN_DATETIME"
        # echo "SCAN_FNAME: $SCAN_FNAME"
    fi

    SCAN_FNAME=$(python2.7 -c "$(cat <<EOF
import re
res = """$SCAN_FNAME"""
res = re.sub(r'[^\x00-\x7F]+','', res)
res = re.sub(r'^[^0-9]+','', res)
res = re.sub(r'(?i)[^0-9a-z]+$','', res)
print(res.strip(' -._\t\n\r'));
EOF
        )")
    }
append-uuid(){
    fname="$1"
    echo $(python2.7 -c "$(cat <<EOF
from uuid import uuid4
fname = "$fname"
D = {
    'f_base'        : fname[:fname.rfind('.')]
    ,'f_ext'        : fname[fname.rfind('.')+1:]
    ,'uuid'         : uuid4().hex[:7]
    }
print("%(f_base)s_%(uuid)s.%(f_ext)s" % D)
EOF
    )")
    }
build_pdf(){

    PG_NAME="$1"".jpg"
    OUTPUT_FPATH=$(printf '%s.pdf' $SCAN_FNAME)
    if [[ -e $OUTPUT_FPATH ]]; then
        tmp=$(uuidgen)
        tmp=${tmp:0:8}
        OUTPUT_FPATH=$(printf '%s_%s.pdf' $SCAN_FNAME $tmp)
    fi

    if [[ $BUILD_METHOD = normal ]]; then
        [[ -z "$DRY_RUN" ]] && convert $(find ./ -type f -name $PG_NAME | sort | xargs) $ROTATION -page Letter "$OUTPUT_FPATH"
        [[ -n "$DRY_RUN" ]] && echo "$(pwd)/"$OUTPUT_FPATH

    elif [[ $BUILD_METHOD = image_extraction ]]; then
        [[ -z "$DRY_RUN" ]] && convert *.jpg $ROTATION -page Letter "$OUTPUT_FPATH"
        [[ -n "$DRY_RUN" ]] && echo "$(pwd)/"$OUTPUT_FPATH
    fi
    OUTPUT_FILES+="$(pwd)/"$OUTPUT_FPATH
    }
build_processed_pdf(){ build_pdf page}
build_orig_pdf(){ build_pdf shot}
process_page_dir(){
    PAGE_DIR=$1
    cd $PAGE_DIR

    get_scan_info

    [[ -n "$EXTRACT_PROCESSED" ]]   \
        && build_processed_pdf      \
        && IMAGE_NAME="page.jpg"
    [[ -n "$EXTRACT_ORIGS" ]]       \
        && build_orig_pdf           \
        && IMAGE_NAME="shot.jpg"

    cd ..
    }
process_scan_group_dir(){
    SCAN_GROUP_DIR=$1
    cd $SCAN_GROUP_DIR                  # i.e., 'Common', 'Home', 'Trip', etc...

    remove_spaces_in_pwd_scan_group_dirs

    if [[ $BUILD_METHOD = normal ]]; then
        for SCAN_DIR in Scan*; do
            process_page_dir $SCAN_DIR
            [[ -n "$SINGLE_DIR" ]] && return
        done

    elif [[ $BUILD_METHOD = image_extraction ]]; then

        if [[ -z "$(bash -c 'for s in Scan*; do break; done' 2>&1)" ]]; then

            for SCAN_DIR in Scan*; do
                cd $SCAN_DIR
                [[ -n "$VERBOSE" ]] && echo "Page Dir: "$SCAN_DIR

                [[ -z "$DRY_RUN" ]] && extract_images && cd $TMP_IMAGE_DIR && CLEANUP+="$(pwd)"
                for f in $(find . -type f | grep -E 'jpg'$ | sort); do
                    REL_FPATH=$(python -c "z='$f'; print(z.lstrip('./'))")
                    PDF_FNAME=$(python -c "z='$REL_FPATH'; print(z.replace('.jpg','.pdf'))")
                    OUT_FPATH="$OUTPUT_DIR/"$PDF_FNAME
                    OUTPUT_FILES+="$PDF_FPATH"
                    [[ -n "$VERBOSE" ]] && echo "Converting: $REL_FPATH $OUT_FPATH"
                    [[ -n "$DRY_RUN" ]] && break 2
                    [[ -z "$DRY_RUN" ]] && convert $REL_FPATH $ROTATION -page Letter "$OUT_FPATH"
                done
                [[ -z "$DRY_RUN" ]] && cd ..

                cd ..
            done

        fi
    fi

    cd ..

    }
package_images(){
    # Setup Debug Env
    [[ -n "$DEBUG" ]] && set -xv

    # Setup Defaults

    [[ -n "$ROTATION" ]] && ROTATION="-rotate $ROTATION"
    #   Create Output Dir if not Exist
    [[ -z "$OUTPUT_DIR_NAME" ]] && OUTPUT_DIR_NAME=MDSCAN_OUTPUT_"${$(uuidgen):0:8}"
    OUTPUT_DIR="$BASE_DIR/$OUTPUT_DIR_NAME"
    EXCLUDE_FOLDERS+=$OUTPUT_DIR_NAME
    OUTPUT_FILES=()
    CLEANUP=()
    [[ -n "$VERBOSE" ]] && echo "Output Dir: $OUTPUT_DIR"
    [[ -z "$DRY_RUN" ]] && mkdir -p $OUTPUT_DIR

    # Start in MDScan Dir
    cd $BASE_DIR/$INPUT_DIR

    # Remove Spaces
    remove_spaces_in_pwd_scan_group_dirs

    # Rename Generic Directories
    try=$(for i in Custom*; do mv $i $(cat $i/folder.dat); done > /dev/null 2>&1)

    # Process Files
    printf "\n%s\n\n" "EXCLUDE DIRECTORIES: $EXCLUDE_FOLDERS"
    for i in $(find . -maxdepth 1 -type d -regex '.*[A-Za-z0-9]+.*' | sed 's/^\.\///' | sort); do
        echo $i
        SKIP=
        for j in $EXCLUDE_FOLDERS; do
            if [[ $i = $j ]]; then
                SKIP=true
                break
            fi
        done

        if [[ -z "$SKIP"  ]]; then

            remove_spaces_in_pwd_scan_group_dirs

            if [[ -z "$(test -d $i || echo 'not exist')" ]]; then

                SCAN_GROUP_DIR=$i
                echo "Scan Group Dir: "$SCAN_GROUP_DIR

                process_scan_group_dir $SCAN_GROUP_DIR

            fi
        fi
    done

    # Return to base dir
    # if [[ -z "$DRY_RUN" ]]; then
    if [[ $BUILD_METHOD = normal ]]; then
        [[ -z $DRY_RUN ]] && cd $OUTPUT_DIR
        FINAL_OUTPUT_FILES=()
        for f_new in $OUTPUT_FILES; do

            # chk=$OUTPUT_FPATH
            # # echo "chk_1: $chk"
            # for f in $OUTPUT_FILES; do
            #     f="$(echo $f|sed 's/\//\n/g')"
            #     # echo "f| grep \$chk: $(echo $f | grep $chk)"
            #     if [[ -n $(echo $f | grep $chk) ]]; then
            #         chk=$(append-uuid $chk)
            #         break
            #     fi
            # done
            # echo "chk_2: $chk"
            new_fname=$(echo $f_new|sed 's/\//\n/g'|tail -n 1)
            for f_out in $FINAL_OUTPUT_FILES; do
                f_out=$(echo $f_out|sed 's/\//\n/g'|tail -n 1)
                if [[ $f_out = $new_fname ]]; then
                    new_fname=$(append-uuid $new_fname)
                    break
                fi
            done

            # [[ -n $new_fname ]] \
            #     && f_out=new

            #     echo "$i changed to $new_fname"
            #     mv $new_fname ./
            #     FINAL_OUTPUT_FILES+=($new_fname)
            # else
            #     mv $i ./

            if [[ -z $DRY_RUN ]]; then
                if [[ (-f $f_new) && (! -f ./$new_fname) ]]; then
                    mv $f_new ./$new_fname
                    FINAL_OUTPUT_FILES+=($f_new)
                else
                    echo "ISSUES WITH CMD: 'mv $f_new ./$new_fname'"
                fi
            fi

        done
    fi
    # fi

    for i in $CLEANUP; do rm -fr $i; done

    MSG="\n\n$FINAL_OUTPUT_FILES\n\nAbove file list saved to directory: $OUTPUT_DIR\n\n"
    [[ -n "$VERBOSE" ]] && printf "%s" $MSG


    # Destroy Debug Env
    [[ -n "$DEBUG" ]] && set +xv
    }

extract_images(){

    remove_spaces_in_pwd_scan_group_dirs

    _image_name="page"
    [[ -n "$EXTRACT_PROCESSED" ]]   && _image_name="page"
    [[ -n "$EXTRACT_ORIGS" ]]       && _image_name="shot"

    [[ -z "$TMP_IMAGE_DIR" ]]       && TMP_IMAGE_DIR="_images"
    mkdir -p $TMP_IMAGE_DIR

    cnt=0
    for i in $(find ./ -iname $_image_name"[.]jpg" -printf "\"%p\"\n"|xargs -I '{}' echo {}|sort); do
        CNT=$(python -c "print '%05d' % ($cnt)")
        UUID=$(echo "${$(uuidgen -t):1:7}")
        EPOCH=$(date +%s)
        FNAME="$EPOCH"_"$CNT"_"$UUID".jpg
        FPATH="$TMP_IMAGE_DIR/$FNAME"
        cp $i $FPATH || echo "err: 'cp $i $FPATH'"
        let cnt+=1
    done

    }
compare_packaged_with_completed(){

    remove_spaces_in_pwd_scan_group_dirs

    BASE_DIR="/home/ub2/ARCHIVE/MDSCAN"
    _from_dir="$BASE_DIR/packaged"
    _to_dir="$BASE_DIR/completed"

    for i in $(find $_from_dir/ -type f -printf "\"%p\"\n"|xargs -I '{}' echo {}|sort); do
        FNAME=$(python -c "z='$i'; print(z[z.rfind('/')+1:])")
        FNAME_BASE=$(python -c "z='$FNAME'; print(z[:z.rfind('.')])")
        CHK_FNAME=$FNAME_BASE"_ocr.pdf"
        if [[ -n $(env ls $_to_dir|grep $CHK_FNAME) ]]; then

            # _from=$(md5sum $_from_dir/$i|cut -d ' ' -f1)
            # _to=$(md5sum $_to_dir/$i|cut -d ' ' -f1)
            # if [[ $_from = $_to ]]; then
            #echo "ok - $i"
            # else
            #     #echo "fail - $i $_from $_to"
            # fi
            # mv $_from_dir/$i $_to_dir/

        else
            # echo " ?? - $i"
            NEW_TMP_PATH="$_from_dir/$CHK_FNAME"
            pypdfocr $i
            mv $NEW_TMP_PATH $_to_dir

        fi
        # echo $i $CHK_FNAME && return

    done
    }

# remove_spaces_in_pwd_scan_group_dirs
# extract_images
# compare_packaged_with_completed

package_images

